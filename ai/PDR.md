# GMX Synthetics — 协议设计审查 (PDR)

版本: 0.1
日期: 2025-08-29

## 1. 目标
- 提供对 `contracts/` 中链上合约的高级别、实施感知审查，以帮助入门、审计和运营。
- 总结架构、关键模块、信任/角色、核心流程、功能标志、安全属性、风险和部署/运营手册。

## 2. 范围
- 此快照中 `contracts/` 下的 Solidity 合约。链下服务（keeper、签名者、前端）仅在与链上接口的部分进行描述。

## 3. 系统概述
- 模式：模块化永续合约/合成协议，具有由 keeper 中介的请求/执行工作流程和提供每区块签名价格的预言机。
- 核心支柱：
  - 状态：`DataStore` 类型化键值对 + 使用键控 `bytes32` 的集合存储 (`contracts/data`)。
  - 访问：`RoleStore` + `RoleModule` 修饰符 (`contracts/role`)。
  - 路由：用户通过 `Router`/`BaseRouter`/`ExchangeRouter` 进入 (`contracts/router`)。
  - 请求生命周期：创建 → 存储 → Keeper 使用预言机价格执行（`contracts/exchange` 中的存款/提款/订单处理器）。
  - 市场和代币：市场配置、池、会计 (`contracts/market`)，每个交易对使用独立的 `MarketToken` 作为 LP 份额的 ERC20。
  - **独立市场代币池设计理由**：
    - 风险隔离：每个交易对的风险完全隔离，一个市场的损失不会影响其他市场的 LP
    - 精确定价：每个池子可以根据其特定资产的供需关系独立定价，避免交叉补贴
    - 灵活参数配置：不同市场可以有不同的费率、资金费率、风险参数等
    - 简化会计：每个池子的会计独立，便于审计和风险管理
    - 流动性激励：可以针对特定市场提供流动性挖矿激励
    - 降低系统性风险：避免单一大额损失影响整个协议的流动性
  - 预言机：签名的中位数最小/最大价格 + 实时馈送验证器 (`contracts/oracle`)。价格每笔交易设置并在之后清除。
  - 事件：`EventEmitter` + `EventUtils` 结构化日志记录 (`contracts/event`)。
  - 功能标志：`FeatureUtils` 通过 `DataStore` 中的键控制函数门控。

## 4. 关键模块
- 角色和访问控制
  - `role/Role.sol`: 定义角色键（例如，`ROLE_ADMIN`、`TIMELOCK_ADMIN`、`TIMELOCK_MULTISIG`、`CONFIG_KEEPER`、`CONTROLLER`、`ROUTER_PLUGIN`、`ORDER_KEEPER`、`FROZEN_ORDER_KEEPER` 等）。
  - `role/RoleStore.sol`: 存储角色、成员和角色缓存；初始部署者是 `ROLE_ADMIN`。
  - `role/RoleModule.sol`: 可重用的修饰符，如 `onlyController`、`onlyOrderKeeper` 等，由 `RoleStore` 支持。

- 状态和配置
  - `data/DataStore.sol`: 用于 `uint/int/address/bool/string/bytes32`、数组和可枚举集合的中央类型化存储。所有变更操作都是 `onlyController`。
  - `data/Keys.sol`: 跨模块使用的命名空间键助手。

- 路由器
  - `router/Router.sol`: 最小的代币转移助手；`pluginTransfer()` 限制为 `onlyRouterPlugin`。
  - `router/BaseRouter.sol`: 通用路由器基础（重入保护、多调用、代币助手），持有对 `Router`、`DataStore`、`EventEmitter` 的引用。
  - `router/ExchangeRouter.sol`: 面向用户的创建/取消/更新请求和费用声明入口。委托给处理器；支持模拟。

- 请求处理器（使用预言机执行）
  - `exchange/DepositHandler.sol`: 创建/执行/取消存款；使用 `DepositVault`、功能标志、全局重入保护和预言机。
  - `exchange/WithdrawalHandler.sol`: 创建/执行/取消提款；使用 `WithdrawalVault`。
  - `exchange/OrderHandler.sol`: 创建/执行/取消/更新订单。使用 `BaseOrderHandler` 组装执行参数并执行冻结订单 keeper 检查。
  - `exchange/BaseOrderHandler.sol`: 共享连接（事件发射器、金库、预言机、推荐）和 `_getExecuteOrderParams`。

- 预言机
  - `oracle/Oracle.sol`: 仅为当前执行验证和存储价格。
    - 输入：压缩的最小/最大价格索引、签名者索引、签名，以及可选的参考价格馈送/实时馈送。
    - 过程：验证签名，计算中位数最小/最大值，检查与参考的偏差，验证区块范围，然后公开价格直到清除。
    - 生命周期：执行前 `setPrices()`；执行后 `clearAllPrices()`；`withOraclePrices` 修饰符确保正确的作用域。
  - `oracle/OracleModule.sol`: 修饰符 `withOraclePrices` 和 `withSimulatedOraclePrices`（模拟总是在最后回滚）。

- 市场和会计（精选）
  - `market/MarketToken.sol`: ERC20 LP 代币，与银行逻辑集成；在流动性变化时铸造/销毁。
  - `market/MarketFactory.sol`、`market/Market*.sol` 和工具：创建/验证市场，计算池价值、费用、资金等。

- 事件和功能标志
  - `event/EventEmitter.sol`、`event/EventUtils.sol`: 工具和处理器使用的结构化事件发射。
  - `feature/FeatureUtils.sol`: 使用 `DataStore` 键的按功能切换（例如，启用/禁用每个处理器的创建/执行/取消/更新）。

- 治理（精选）
  - `gov/GovToken.sol`: 带角色的 ERC20Votes 治理代币。
  - `gov/GovTimelockController.sol`、`gov/ProtocolGovernor.sol`: 时间锁和治理器脚手架。

## 5. 核心流程
- 防止用户价格抢跑的两步执行：
  1) 用户通过 `ExchangeRouter` 提交请求（创建存款/提款/订单）。请求被持久化（StoreUtils 库）并在金库中记录费用。
  2) 链下 keeper 观察最终确定的区块，获取签名价格，然后使用 `OracleUtils.SetPricesParams` 调用处理器 `execute*()`。
  - 通过 `withOraclePrices` 为交易设置预言机价格，执行发生，然后清除价格。

- 更新/取消语义：
  - 当功能允许且约束（例如冷却时间）满足时，用户可以 `updateOrder`（非市价订单）和 `cancel*`。
  - 如果执行前置条件失败，市价订单通常被取消；其他订单可能被冻结以防止操纵，直到 `FROZEN_ORDER_KEEPER` 或用户通过更新解冻。

## 6. 信任模型和角色
- 管理员/治理：`ROLE_ADMIN`、`TIMELOCK_ADMIN`、`TIMELOCK_MULTISIG` 通过控制器管理角色分配和协议级设置。
- 控制器：被授予 `CONTROLLER` 的实体协调 `DataStore` 变更并调用处理器和预言机内的特权流程。
- Keeper：`ORDER_KEEPER`、`FROZEN_ORDER_KEEPER`、`PRICING_KEEPER`、`LIQUIDATION_KEEPER`、`ADL_KEEPER` 执行时间敏感的操作。
- 路由器插件：具有 `ROUTER_PLUGIN` 的地址可以通过 `Router.pluginTransfer` 从用户批准中提取代币。

假设：生产部署将控制器和 keeper 分配给治理控制的多签/机器人，具有最小权限和时间锁。

## 7. 安全属性
- 重入保护
  - 路由器上的 `ReentrancyGuard`；处理器间的 `GlobalReentrancyGuard` 通过 `DataStore` 实现 `globalNonReentrant` 模式。
  - **全局重入限制的必要性**：由于 GMX Synthetics 是一个复杂的多合约系统，存在以下风险场景需要全局重入保护：
    - 跨处理器攻击：恶意合约可能通过回调在一个处理器执行过程中调用另一个处理器，导致状态不一致
    - 价格状态污染：在预言机价格设置期间的重入可能导致价格状态被污染或不正确地重复使用
    - 市场状态竞争：同时执行的订单、存款、提款可能导致市场状态计算错误
    - 资金锁定风险：重入可能导致资金在不同合约间的转移过程中被锁定
    - 全局重入锁确保在任何时候只有一个关键操作在执行，保护整个系统状态的一致性
  - 预言机修饰符警告关于 delegatecall/multicall 并确保执行后清除价格。

- 授权
  - 所有状态更改入口点使用 `RoleModule` 检查（`onlyController`，keeper 特定修饰符）。`DataStore` setter 都是 `onlyController`。

- 预言机正确性
  - 签名者最小/最大值的中位数，具有实时馈送检查和参考馈送偏差界限。
  - 强制递增价格数组、签名者索引唯一性、区块年龄界限和非零价格。

- 反操纵
  - 冻结订单和冻结订单 keeper 角色在输出金额可能失败时分离执行权力。
  - 功能标志允许独立禁用创建/执行/取消/更新以缓解事故。

- Gas 安全
  - 处理器计算估计 gas 并验证可用 gas；可配置的执行费用检查；有界错误 gas。

## 8. 功能标志和配置
- `FeatureUtils.validateFeature(...)` 使用 `DataStore` 中的 `Keys` 控制每个函数的行为。
- 典型标志：启用/禁用存款/提款/订单的创建/执行/取消/更新；费用/声明功能。

## 9. 外部集成
- 价格馈送：`oracle/` 中的参考馈送和实时馈送验证器；`DataStore` 中的乘数将外部小数位转换为内部 30 位小数。
- 推荐：订单路径中集成的 `IReferralStorage`。
- 回调：每个账户/市场的可选保存回调合约，用于清算/ADL 回调。

## 10. 风险和缓解措施
- 预言机/签名者风险：串通或过时的签名者可能扭曲价格。通过 N-of-M 中位数、与参考馈送的偏差检查、区块年龄限制和轮换签名者的操作手册来缓解。
- **全局价格操纵防护**：为防止恶意行为者操纵全局平均价格，系统采用以下机制：
  - 多签名者中位数价格：要求多个独立签名者提供价格，取中位数而非平均值，减少单一或少数签名者的影响力
  - 参考价格偏差检查：与外部价格馈送（如 Chainlink）进行偏差比较，超出阈值的价格被拒绝
  - 区块时间窗口限制：价格签名包含区块范围，防止过期价格被重复使用
  - 实时价格验证：结合实时馈送验证器检查价格合理性
  - 价格上下限保护：设置每个资产的价格变化上下限，防止极端价格操纵
- Keeper 风险/DoS：缺失或恶意的 keeper 可能导致执行停滞；冻结订单可能堆积。通过多样化的 keeper 集合、监控和手动管理路径来缓解。
- 配置/控制器泄露：`onlyController` 控制关键状态。使用时间锁多签、严格角色分离和链上监控。
- 精度和小市值代币：使用乘数的 30 位小数内部数学；验证每个资产的乘数配置和最小/最大界限。
- 通过多调用的重入：可支付多调用使用 delegatecall；函数对 `msg.value` 重用要谨慎。保持外部调用最少，在金库中优先使用拉取模式。

## 11. 测试和模拟计划
- 每个处理器的单元测试：创建/执行/取消/更新流程，包括功能切换和边缘情况。
- 预言机测试：签名打包、索引唯一性、中位数正确性、实时/报告验证、clearAllPrices 生命周期。
- 模糊/属性测试：订单更新冻结/解冻不变性；gas 费用会计界限；金库会计守恒。
- 场景测试：多市场 LP 添加/移除、资金费用累积、清算和 ADL 执行路径。
- 模拟：`simulateExecute*` 入口点验证失败路径而不持久化状态。

## 12. 部署和运营（建议顺序）
1) 部署 `RoleStore`，授予部署多签 `ROLE_ADMIN`。
2) 使用 `RoleStore` 部署 `DataStore`；部署 `EventEmitter`。
3) 部署预言机堆栈：`OracleStore`、`Oracle`（连接 `RealtimeFeedVerifier`），在 `DataStore` 中设置签名者和乘数。
4) 部署 `Router`、`BaseRouter` 依赖项和带有处理器地址的 `ExchangeRouter`。
5) 部署金库：`OrderVault`、`DepositVault`、`WithdrawalVault` 和市场合约（`MarketFactory`、`MarketToken`）。
6) 部署处理器：`OrderHandler`、`DepositHandler`、`WithdrawalHandler` 连接存储、金库、预言机、交换/推荐。
7) 分配角色：控制器、keeper、路由器插件、费用/市场 keeper、冻结订单 keeper。
8) 在 `DataStore` 中初始化功能标志（谨慎启用），设置费用参数、稳定价格、乘数。
9) 治理：部署 `GovToken`、`ProtocolGovernor`、`GovTimelockController`；将管理员迁移到时间锁。
10) 监控：设置 keeper 机器人、签名者轮换、功能切换和执行积压的警报。

## 13. 值得注意的文件（非详尽）
- 角色：`contracts/role/Role.sol`、`RoleStore.sol`、`RoleModule.sol`。
- 状态：`contracts/data/DataStore.sol`、`Keys.sol`。
- 路由器：`contracts/router/Router.sol`、`BaseRouter.sol`、`ExchangeRouter.sol`。
- 预言机：`contracts/oracle/Oracle.sol`、`OracleModule.sol`、`OracleStore.sol`、`OracleUtils.sol`。
- 交易：`contracts/exchange/*Handler.sol`、`BaseOrderHandler.sol`、`ExchangeUtils.sol`。
- 金库：`contracts/order/OrderVault.sol`、`deposit/DepositVault.sol`、`withdrawal/WithdrawalVault.sol`。
- 市场：`contracts/market/*` 包括 `MarketToken.sol`、`MarketFactory.sol`。
- 事件和功能：`contracts/event/*`、`feature/FeatureUtils.sol`。
- 治理：`contracts/gov/*`。

## 14. 用户故事和使用场景

### 流动性提供者场景
**故事**: 作为流动性提供者，我想要安全地向 ETH/USD 市场提供流动性并获得交易费用收入。

**具体示例**: 用户向 ETH/USD 市场存入 1 ETH (价值 $3000) + 3000 USDC

**用户钱包交互次数**: **仅需1次钱包签名**
- 用户在前端界面选择存款数量后，点击存款按钮
- 钱包弹出签名请求，用户确认一次即可完成整个存款流程
- 无需多次签名或等待中间确认

**两步执行流程和风险防范**:

**第一步: 创建存款请求 (`createDeposit`)**
- 用户提交存款交易，包含代币数量和执行费用
- 系统接收代币并创建存款记录，但**不立即执行**
- 存款请求进入待执行队列

**第二步: Keeper 执行存款**
- 链下 Keeper 监控区块确认后，获取最新价格数据
- Keeper 调用执行函数，使用实时预言机价格完成存款
- 计算LP份额并铸造给用户

**风险防范机制**:

1. **防止价格操纵攻击**
   - 如果用户可以在同一区块内创建和执行存款，恶意用户可能：
   - 先操纵代币价格（通过大额交易或闪电贷）
   - 立即存款获得更多LP份额
   - 价格恢复后获得不当利益
   - **解决方案**: 分离创建和执行，使用不同区块的价格

2. **确保价格公平性**
   - 所有同一批次的存款都使用相同的预言机价格执行
   - 避免单个用户获得价格优势
   - 保证所有LP持有者权益平等

**用户体验优化**:
- 虽然是两步执行，但用户只需操作一次
- 执行时间通常在几分钟内完成
- 用户可以随时查看存款状态和预估收到的LP数量

**LP 份额计算公式**:

**第一步: 计算用户存款价值**
```
存款总价值 = 长代币数量 乘以 长代币价格 加上 短代币数量 乘以 短代币价格
```

**第二步: 计算池子总价值**

池子总价值包含四个部分的计算：

1. **基础代币池价值**
```
长代币价值 = 池中长代币数量 乘以 长代币当前价格
短代币价值 = 池中短代币数量 乘以 短代币当前价格
基础池价值 = 长代币价值 加上 短代币价值
```

2. **加上借贷费用收入**
```
多头借贷费用 = 所有多头仓位累计的借贷费用
空头借贷费用 = 所有空头仓位累计的借贷费用
总借贷费用 = 多头借贷费用 加上 空头借贷费用
池子借贷费用收入 = 总借贷费用 乘以 池子分成比例
调整后池价值 = 基础池价值 加上 池子借贷费用收入
```

3. **减去交易者未实现盈亏**

**多头仓位初始成本计算说明**：
- **openInterest（持仓总成本）**：记录所有多头仓位开仓时的美元总价值，这是交易者实际支付的总成本
- **openInterestInTokens（持仓代币总量）**：记录所有多头仓位对应的指数代币总数量
- **计算原理**：当交易者开多头仓位时，系统记录其开仓时支付的美元成本和获得的代币数量

```
多头仓位当前价值 = 持仓代币总量 乘以 当前指数代币价格
多头盈亏 = 多头仓位当前价值 减去 多头仓位初始成本
空头盈亏 = 空头仓位初始成本 减去 空头仓位当前价值
净盈亏 = 多头盈亏 加上 空头盈亏
扣除盈亏后池价值 = 调整后池价值 减去 净盈亏
```

**举例说明多头仓位成本**：
- 用户A：开仓时ETH价格$2000，投入$10000，获得5个ETH代币等价仓位
- 用户B：开仓时ETH价格$3000，投入$15000，获得5个ETH代币等价仓位
- 多头仓位初始成本 = $10000 + $15000 = $25000
- 持仓代币总量 = 5 + 5 = 10个ETH等价
- 如果当前ETH价格$3500，多头仓位当前价值 = 10 × $3500 = $35000
- 多头盈亏 = $35000 - $25000 = +$10000（多头盈利）

4. **减去价格影响缓冲池**
```
影响池金额 = 为价格影响预留的缓冲资金数量
影响池价值 = 影响池金额 乘以 指数代币价格
最终池价值 = 扣除盈亏后池价值 减去 影响池价值
```

**第三步: LP 份额分配计算**

系统根据三种不同情况计算新增 LP 份额：

**情况一：全新市场首次存款**
```
如果 当前LP总供应量等于零 且 池价值等于零
则 新增LP份额 = 存款总价值（按1美元等于1LP的比例）
```

**情况二：池中有资产但无LP供应**
```
如果 当前LP总供应量等于零 且 池价值大于零
则 新增LP份额 = 池价值 加上 存款总价值（按1美元等于1LP的比例）
```

**情况三：正常存款情况**
```
新增LP份额 = 现有LP总数量 乘以 存款总价值 除以 最终池价值
```

**核心公式理解**：
- **仓位成本记录机制**：
  - openInterest：所有仓位开仓时实际支付的美元成本总和
  - openInterestInTokens：所有仓位对应的代币数量总和
  - 每个仓位根据开仓时的价格确定代币数量，但成本按实际美元计算
- **盈亏计算逻辑**：
  - 多头盈亏 = （代币总量 × 当前价格）- 开仓成本总额
  - 空头盈亏 = 开仓成本总额 - （代币总量 × 当前价格）
- **池价值动态变化**：交易者盈利会减少池价值，亏损会增加池价值
- **份额分配公平性**：新LP按存款占池子总价值的比例获得份额，不稀释现有LP权益

具体计算示例:
存款价值 = 1 × $3000 + 3000 = $6000
假设:
- 池中ETH价值 = $500,000 (166.67 ETH × $3000)
- 池中USDC价值 = $400,000
- 多头仓位总盈亏 = +$50,000 (ETH价格从$2800涨到$3000)
- 空头仓位总盈亏 = -$50,000
- 未实现盈亏 = $50,000 + (-$50,000) = $0
池总价值 = $500,000 + $400,000 + $0 = $900,000
当前LP总供应量 = 100,000
LP份额铸造量 = ($6000 × 100,000) / $900,000 = 667 LP代币


**提款时可兑换金额**:
```
用户可提取价值 = (用户LP份额 / 总LP供应量) × 当前池总价值
用户ETH提取量 = 可提取价值 × (池中ETH占比)
用户USDC提取量 = 可提取价值 × (池中USDC占比)

示例: 如果用户持有600 LP代币，池总价值增长到$1,100,000
可提取价值 = (600 / 100,000) × $1,100,000 = $6,600
收益 = $6,600 - $6,000 = $600 (10%收益)
```

- **风险考虑**: 仓位不平衡可能导致价格影响损失，但风险隔离在单一市场内

### 永续交易者场景  
**故事**: 作为交易者，我想要以 10x 杠杆做多 ETH，设置止损以限制损失。
- **流程**: 用户提供 1000 USDC 抵押品，创建 10000 USDC 规模的多头仓位，设置 5% 止损
- **系统行为**:
  - ExchangeRouter 接收抵押品和订单参数
  - OrderHandler 创建增仓订单并存储在 DataStore
  - Keeper 使用预言机价格执行，计算借贷费用、资金费率和价格影响
  - 仓位被记录，用户可以监控盈亏
  - 如果价格触发止损条件，冻结订单机制防止恶意操作
- **保护机制**: 全局重入锁防止在执行过程中的恶意重入攻击

### 交换用户场景
**故事**: 作为 DeFi 用户，我想要将 1 ETH 交换为 USDC，要求最少获得 2000 USDC。
- **流程**: 用户通过 ExchangeRouter 提交交换订单，指定最小输出金额
- **系统行为**:
  - 系统路由通过最优的市场池序列
  - 计算价格影响和交换费用
  - 验证输出是否满足最小要求
  - 执行交换并转移 USDC 到用户钱包
- **保护**: 价格影响上限防止大额交易过度影响池价格

### 清算和风险管理场景
**故事**: 作为协议，我需要自动清算抵押品不足的仓位以保护系统偿付能力。
- **触发条件**: 用户的 ETH 多头仓位由于价格下跌导致抵押品率低于维持保证金
- **系统行为**:
  - LiquidationHandler 检测到仓位可清算
  - 计算清算价格影响和费用
  - 强制平仓并分配清算奖励给执行者
  - 更新市场状态和用户可声明余额
- **ADL 机制**: 如果清算无法充分平衡市场，自动减仓机制会减少盈利仓位

### 治理和紧急响应场景
**故事**: 作为协议治理，当发现安全问题时，我需要能够快速暂停特定功能。
- **紧急情况**: 发现订单执行中的潜在漏洞
- **响应机制**:
  - 通过 FeatureUtils 禁用订单创建功能
  - 保持现有仓位的正常运作
  - 允许用户提款和声明资金
  - 通过时间锁治理部署修复后重新启用
- **角色分离**: 不同的 keeper 角色确保即使部分组件受损，其他功能仍可正常运行

## 15. 待解决问题/后续事项
- 升级策略：当前合约是非代理的；确认在版本间的升级和迁移方法。
- 紧急操作：存在每个功能的枚举暂停路径；确认事故运营手册和时间锁绕过条件（如有）。
- 参数界限：记录 gas 配置、偏差因子、资金参数和每资产乘数的建议范围。
- Keeper/SLA：定义冻结订单和 ADL 的 keeper 活跃目标和后备执行器。

---
从代码库检查中准备；在主网更改之前与当前部署细节保持一致。

